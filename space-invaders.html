<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Space Invaders - ArcadeMaster</title>
    <link rel="stylesheet" href="styles.css"> 
    <style>
        /* Styles sp√©cifiques au jeu */
        #gameCanvas { 
            border: 2px solid #00ff00; 
            background-color: #000; 
        }
        .game-title { 
            color: #00ff00; 
            margin-top: 20px; 
            margin-bottom: 20px;
        }
        body { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding-top: 55px;
            min-height: 100vh;
        } 
        
        /* Conteneur principal: Jeu au centre, Infos √† Gauche, Classement √† Droite */
        #main-game-area {
            display: flex;
            flex-direction: row; 
            align-items: flex-start; /* Aligner les trois blocs en haut */
            gap: 20px; /* Espace entre les blocs */
            width: fit-content; 
            margin: 20px auto; /* Centrer le tout */
        }
        
        /* Conteneur du jeu (Canvas et Bouton) */
        #game-center-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- Panneau d'Information Personnelle (Gauche) --- */
        #personal-score-panel {
            width: 250px; 
            margin-top: 50px; 
            background-color: var(--color-surface);
            border: 1px solid var(--color-primary);
            border-radius: 8px;
            padding: 15px;
            color: var(--color-text);
        }
        #personal-score-panel h3 {
            color: var(--color-secondary);
            margin-top: 0;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        #personal-score-panel p {
            font-size: 1.1em;
            margin: 5px 0;
        }
        
        /* --- Bar d'information du score en cours (Au dessus du canvas) --- */
        #current-info-bar { 
            color: white; 
            font-size: 1.4em; 
            display: flex; 
            justify-content: space-around;
            width: 800px;
            margin-bottom: 10px;
            padding: 10px 0;
            background-color: #1a1a1a;
            border-radius: 5px;
        }
        #reset-button {
            background-color: #f39c12; 
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-top: 10px;
            margin-bottom: 20px;
            display: none; 
        }
        #reset-button:hover {
            background-color: #e67e22; 
        }
        
        /* --- Classement Mondial (Droite) --- */
        #leaderboard-panel {
            width: 300px; 
            margin-top: 50px; 
            background-color: var(--color-surface);
            border: 1px solid var(--color-primary);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }
        
        #leaderboardTitle {
            background-color: #3a3a3a;
            color: var(--color-primary);
            padding: 10px;
            text-align: center;
            font-size: 1.2em;
            border-bottom: 1px solid var(--color-primary);
        }
        
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .leaderboard-table th, .leaderboard-table td {
            padding: 5px 8px; 
            text-align: left;
            border-bottom: 1px solid #333;
        }
        .leaderboard-table th {
             background-color: #2a2a2a;
             color: var(--color-primary);
        }
        .leaderboard-table td:nth-child(4) { 
            text-align: right;
            font-weight: bold;
            color: var(--color-secondary);
        }
        .leaderboard-pdp {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            vertical-align: middle;
            border: 1px solid var(--color-primary);
        }
        .leaderboard-table th:nth-child(1), .leaderboard-table td:nth-child(1) { width: 40px; text-align: center;}
        .leaderboard-table th:nth-child(3), .leaderboard-table td:nth-child(3) { width: 30px;}
        .leaderboard-table th:nth-child(4), .leaderboard-table td:nth-child(4) { width: 70px;}

    </style>
    <script>
        // --- Fonction du Menu Hamburger (CORRIG√âE : D√©plac√©e dans le HEAD) ---
        function toggleMenu(x) {
            x.classList.toggle("change");
            const sidebar = document.getElementById("sidebar");
            
            if (sidebar.style.width === "250px") {
                sidebar.style.width = "0";
            } else {
                sidebar.style.width = "250px";
            }
        }
    </script>
</head>
<body>
    
    <div id="navbar">
        <div class="hamburger-menu" onclick="toggleMenu(this)">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
        </div>
        <div id="auth-controls">
            </div>
    </div>

    <div id="sidebar">
        <a href="index.html">üè† Accueil</a>
        <a href="jeux.html">üïπÔ∏è Menu Jeux</a>
        <a href="credits.html">üìù Cr√©dits</a>
        <a href="authentification.html">‚öôÔ∏è Compte</a>
    </div>

    <h1 class="game-title">SPACE INVADERS</h1>
    
    <div id="main-game-area">
        
        <div id="personal-score-panel">
            <h3>Score Personnel</h3>
            <p><strong>Joueur :</strong> <span id="personal-username">D√©connect√©</span></p>
            <p><strong>Meilleur Score :</strong> <span id="personal-high-score">-</span></p>
            <p><strong>Rang Mondial :</strong> <span id="personal-rank">-</span></p>
        </div>

        <div id="game-center-container">
            <div id="current-info-bar">
                <span>Score: <span id="scoreValue">0</span></span>
                <span>Meilleur Score Partie: <span id="highScoreDisplay">-</span></span> 
            </div>
            
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            
            <button id="reset-button" onclick="resetGameAndStart()">Recommencer la Partie</button>
        </div>

        <div id="leaderboard-panel">
            <div id="leaderboardTitle">
                üèÜ CLASSEMENT MONDIAL (TOP 10)
            </div>

            <div id="leaderboardContainer">
                <table class="leaderboard-table">
                    <thead>
                        <tr><th>Rng</th><th>Joueur</th><th>PDP</th> <th>Score</th></tr>
                    </thead>
                    <tbody id="leaderboardTableBody">
                        <tr><td colspan="4" style="text-align:center;">Chargement...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        
    </div>

    <script src="auth.js"></script>
    <script>
        // --- Fonctions du Classement Int√©gr√© ---
        const DEFAULT_PDP_URL = 'https://i.imgur.com/39hN7hG.png'; 
        const GAME_ID = 'space_invaders';
        
        function renderLeaderboard() {
            const leaderboardBody = document.getElementById('leaderboardTableBody');
            
            if (typeof getFullLeaderboard === 'undefined' || typeof getUserData === 'undefined') {
                leaderboardBody.innerHTML = '<tr><td colspan="4">Erreur: auth.js non charg√©.</td></tr>';
                return;
            }

            const fullLeaderboard = getFullLeaderboard(GAME_ID);
            const leaderboardData = fullLeaderboard.slice(0, 10);
            leaderboardBody.innerHTML = ''; 

            if (leaderboardData.length === 0) {
                 leaderboardBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">Aucun score enregistr√©.</td></tr>';
                 return;
            }

            leaderboardData.forEach((entry, index) => {
                const rank = index + 1;
                let trophy = '';
                
                const userData = getUserData(entry.username);
                const pdpUrl = userData && userData.pdp ? userData.pdp : DEFAULT_PDP_URL;

                if (rank === 1) {
                    trophy = '<span style="font-size: 1.2em;">ü•á</span>';
                } else if (rank === 2) {
                    trophy = '<span style="font-size: 1.2em;">ü•à</span>';
                } else if (rank === 3) {
                    trophy = '<span style="font-size: 1.2em;">ü•â</span>';
                }

                const row = leaderboardBody.insertRow();
                
                row.insertCell().innerHTML = `${trophy} ${rank}`;
                row.insertCell().textContent = entry.username;
                row.insertCell().innerHTML = `<img src="${pdpUrl}" alt="PDP" class="leaderboard-pdp">`;
                row.insertCell().textContent = entry.score;
            });
            
            updatePersonalScorePanel(fullLeaderboard);
        }
        
        function updatePersonalScorePanel(fullLeaderboard) {
             const user = getCurrentUser();
             const rankElement = document.getElementById('personal-rank');
             const scoreElement = document.getElementById('personal-high-score');
             const usernameElement = document.getElementById('personal-username');
             
             if (!user) {
                 usernameElement.textContent = 'D√©connect√©';
                 scoreElement.textContent = '-';
                 rankElement.textContent = '-';
                 return;
             }

             usernameElement.textContent = user;
             const userData = getUserData(user);
             let personalHighScore = 0;
             if (userData && userData.games && userData.games[GAME_ID]) {
                 personalHighScore = userData.games[GAME_ID].highScore || 0;
             }
             scoreElement.textContent = personalHighScore;
             
             const userRankIndex = fullLeaderboard.findIndex(entry => entry.username === user);
             if (userRankIndex !== -1) {
                 rankElement.textContent = `#${userRankIndex + 1}`;
             } else {
                 rankElement.textContent = 'N/A';
             }
        }
        
        let currentHighScore = 0; 
        
        function loadHighScore() {
            const user = getCurrentUser();
            const highScoreElement = document.getElementById('highScoreDisplay').querySelector('span');
            
            if (user && typeof getUserData !== 'undefined') {
                const userData = getUserData(user);
                if (userData && userData.games && userData.games[GAME_ID]) {
                    currentHighScore = userData.games[GAME_ID].highScore || 0;
                    highScoreElement.textContent = currentHighScore;
                    return;
                }
            }
            currentHighScore = 0;
            highScoreElement.textContent = '-';
        }

        // --- Initialisation ---
        document.addEventListener('DOMContentLoaded', () => {
             if (typeof renderAuthControls === 'function') {
                 renderAuthControls();
             }
             loadHighScore(); 
             renderLeaderboard(); 
             resetGame();
             requestAnimationFrame(gameLoop);
        });
        
        // --- LOGIQUE DU JEU SPACE INVADERS ---
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreValue');
        const resetButton = document.getElementById('reset-button');
        
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        let score = 0;
        let gameOver = false;
        
        let player = {
            x: GAME_WIDTH / 2,
            y: GAME_HEIGHT - 50,
            size: 20, 
            speed: 5,
            angle: -Math.PI / 2,
            velX: 0,
            velY: 0
        };

        let mouse = { x: 0, y: 0 };
        let bullets = [];
        const BULLET_SPEED = 10;
        let lastShotTime = 0;
        const FIRE_RATE = 200; 
        let enemies = [];
        const ENEMY_SIZE = 30; 
        const ENEMY_SPEED_BASE = 0.5; 
        let enemySpawnInterval = 1500; 
        let lastSpawnTime = 0;
        let animationFrameId = null;

        // --- Dessin des "persos" avec police fiable ---
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle + Math.PI / 2); 
            ctx.fillStyle = '#00ff00';
            ctx.font = `${player.size * 2.5}px Arial, sans-serif`; 
            ctx.textAlign = 'center';
            ctx.fillText("‚ñ≤", 0, player.size * 0.7); 
            ctx.restore();
        }

        function drawBullets() {
            ctx.fillStyle = '#ff0000';
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2); 
                ctx.fill();
            });
        }

        function drawEnemies() {
            ctx.fillStyle = '#ff0000';
            enemies.forEach(enemy => {
                ctx.font = `${ENEMY_SIZE * 1.3}px Arial, sans-serif`; 
                ctx.textAlign = 'center';
                ctx.fillText("üëæ", enemy.x, enemy.y + ENEMY_SIZE / 4); 
            });
        }
        
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = '#ff0000';
            ctx.font = '60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 30);
            ctx.font = '30px Arial';
            ctx.fillText(`Score final : ${score}`, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30);
            ctx.fillText('Appuyez sur ESPACE ou cliquez sur Recommencer', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 80);
            resetButton.style.display = 'block'; 
        }

        function updateEnemies() {
            const scoreBonusSpeed = Math.floor(score / 50) * 0.1;
            
            enemies.forEach((enemy, index) => {
                const currentSpeed = Math.min(3.0, ENEMY_SPEED_BASE + scoreBonusSpeed);
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    enemy.x += (dx / distance) * currentSpeed;
                    enemy.y += (dy / distance) * currentSpeed;
                }

                const collisionDist = player.size / 2 + ENEMY_SIZE / 2;
                const distPlayerEnemy = Math.sqrt(Math.pow(player.x - enemy.x, 2) + Math.pow(player.y - enemy.y, 2));
                
                if (distPlayerEnemy < collisionDist) {
                    const user = getCurrentUser();
                    if (user && typeof saveGameData !== 'undefined') {
                        saveGameData(user, GAME_ID, { score: score });
                        loadHighScore(); 
                        renderLeaderboard(); 
                    } 
                    gameOver = true;
                }
            });
        }
        
        function updatePlayer() {
            player.x += player.velX;
            player.y += player.velY;
            if (player.x < 0) player.x = 0;
            if (player.x > GAME_WIDTH) player.x = GAME_WIDTH;
            if (player.y < 0) player.y = 0;
            if (player.y > GAME_HEIGHT) player.y = GAME_HEIGHT;
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            player.angle = Math.atan2(dy, dx); 
        }

        function updateBullets() {
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.velX;
                bullet.y += bullet.velY;
                if (bullet.x < 0 || bullet.x > GAME_WIDTH || bullet.y < 0 || bullet.y > GAME_HEIGHT) {
                    bullets.splice(index, 1);
                }
            });
        }

        function checkCollisions() {
            for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = bullets[bIndex];
                for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                    const enemy = enemies[eIndex];
                    const distance = Math.sqrt(Math.pow(bullet.x - enemy.x, 2) + Math.pow(bullet.y - enemy.y, 2));

                    if (distance < ENEMY_SIZE / 2 + 5) { 
                        enemies.splice(eIndex, 1);
                        bullets.splice(bIndex, 1);
                        score += 10;
                        scoreDisplay.textContent = score;

                        if (enemySpawnInterval > 300 && score % 200 === 0) {
                            enemySpawnInterval = Math.max(300, enemySpawnInterval - 100);
                        }
                        break; 
                    }
                }
            }
        }
        
        function shoot() {
            const now = Date.now();
            if (now - lastShotTime > FIRE_RATE) {
                lastShotTime = now;
                const velX = BULLET_SPEED * Math.cos(player.angle);
                const velY = BULLET_SPEED * Math.sin(player.angle);
                const startX = player.x + (player.size * Math.cos(player.angle));
                const startY = player.y + (player.size * Math.sin(player.angle));
                bullets.push({ x: startX, y: startY, velX, velY });
            }
        }

        function spawnEnemy() {
            const now = Date.now();
            if (now - lastSpawnTime > enemySpawnInterval) {
                lastSpawnTime = now;
                const x = Math.random() * GAME_WIDTH;
                const y = -ENEMY_SIZE;
                enemies.push({ x, y, speed: ENEMY_SPEED_BASE }); 
            }
        }
        
        function resetGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            score = 0;
            scoreDisplay.textContent = 0;
            gameOver = false;
            enemies = [];
            bullets = [];
            player.x = GAME_WIDTH / 2;
            player.y = GAME_HEIGHT - 50;
            player.velX = 0;
            player.velY = 0;
            enemySpawnInterval = 1500;
            resetButton.style.display = 'none'; 
        }
        
        function resetGameAndStart() {
            resetGame();
            gameLoop();
        }

        function gameLoop() {
            if (gameOver) {
                drawGameOver();
                animationFrameId = null;
                return;
            }

            updatePlayer();
            updateBullets();
            spawnEnemy();
            updateEnemies();
            checkCollisions();
            
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            drawPlayer();
            drawBullets();
            drawEnemies();

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // --- √âv√©nements ---
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'q') player.velX = -player.speed;
            else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') player.velX = player.speed;
            else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'z') player.velY = -player.speed;
            else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') player.velY = player.speed;
            
            if (gameOver && e.key === ' ') { 
                e.preventDefault();
                resetGameAndStart();
            }
        });

        document.addEventListener('keyup', (e) => {
            if ((e.key === 'ArrowLeft' || e.key.toLowerCase() === 'q') && player.velX < 0) player.velX = 0;
            else if ((e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') && player.velX > 0) player.velX = 0;
            else if ((e.key === 'ArrowUp' || e.key.toLowerCase() === 'z') && player.velY < 0) player.velY = 0;
            else if ((e.key === 'ArrowDown' || e.key.toLowerCase() === 's') && player.velY > 0) player.velY = 0;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('click', () => {
            if (!gameOver) {
                shoot();
            }
        });

        window.resetGameAndStart = resetGameAndStart; 
        window.renderLeaderboard = renderLeaderboard; 
    </script>
</body>
</html>
