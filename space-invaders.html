<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Space Invaders - ArcadeMaster</title>
    <link rel="stylesheet" href="styles.css"> 
    <style>
        /* Styles sp√©cifiques au jeu */
        #gameCanvas { 
            border: 2px solid #00ff00; 
            background-color: #000; 
            margin-top: 20px; 
            margin-bottom: 20px;
        }
        #infoPanel { 
            color: white; 
            margin-top: 10px; 
            font-size: 1.2em; 
        }
        .game-title { 
            color: #00ff00; 
            margin-top: 20px; 
        }
        body { 
            overflow: hidden; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding-top: 55px;
        } 
        
        /* Style du bouton Recommencer */
        #reset-button {
            background-color: #f39c12; 
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-bottom: 20px;
            display: none; 
        }
        #reset-button:hover {
            background-color: #e67e22; 
        }
    </style>
</head>
<body>
    
    <div id="navbar">
        <div class="hamburger-menu" onclick="toggleMenu(this)">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
        </div>
        <div id="auth-controls">
            </div>
    </div>

    <div id="sidebar">
        <a href="index.html">üè† Accueil</a>
        <a href="jeux.html">üïπÔ∏è Menu Jeux</a>
        <a href="credits.html">üìù Cr√©dits</a>
        <a href="classement.html">üèÜ Classement</a>
    </div>

    <h1 class="game-title">SPACE INVADERS</h1>
    
    <div id="infoPanel">Score: <span id="scoreValue">0</span></div>
    
    <button id="reset-button" onclick="resetGameAndStart()">Recommencer la Partie</button>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script src="auth.js"></script>
    <script>
        // --- 1. Fonctions de la Navbar ---
        function toggleMenu(x) {
            x.classList.toggle("change");
            const sidebar = document.getElementById("sidebar");
            if (sidebar.style.width === "250px") {
                sidebar.style.width = "0";
            } else {
                sidebar.style.width = "250px";
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
             setTimeout(() => {
                 if (typeof renderAuthControls === 'function') {
                     renderAuthControls();
                 }
             }, 100);
        });
        
        // --- 2. LOGIQUE DU JEU SPACE INVADERS ---
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreValue');
        const resetButton = document.getElementById('reset-button');
        
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        let score = 0;
        let gameOver = false;
        
        let player = {
            x: GAME_WIDTH / 2,
            y: GAME_HEIGHT - 50,
            size: 20, 
            speed: 5,
            angle: -Math.PI / 2,
            velX: 0,
            velY: 0
        };

        let mouse = { x: 0, y: 0 };
        let bullets = [];
        const BULLET_SPEED = 10;
        let lastShotTime = 0;
        const FIRE_RATE = 200; 
        let enemies = [];
        const ENEMY_SIZE = 30; 
        const ENEMY_SPEED_BASE = 0.5; 
        let enemySpawnInterval = 1500; 
        let lastSpawnTime = 0;
        let animationFrameId = null;

        // --- Fonctions de Dessin ---
        function drawPlayer() {
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle + Math.PI / 2); 
            ctx.fillStyle = '#00ff00';
            ctx.font = `${player.size * 2}px monospace`; 
            ctx.textAlign = 'center';
            ctx.fillText("‚ñ≤", 0, player.size * 0.7); 
            ctx.restore();
        }

        function drawBullets() {
            ctx.fillStyle = '#ff0000';
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2); 
                ctx.fill();
            });
        }

        function drawEnemies() {
            ctx.fillStyle = '#ff0000';
            enemies.forEach(enemy => {
                ctx.font = `${ENEMY_SIZE}px monospace`;
                ctx.textAlign = 'center';
                // L'emoji monstre üëæ
                ctx.fillText("üëæ", enemy.x, enemy.y + ENEMY_SIZE / 4); 
            });
        }
        
        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = '#ff0000';
            ctx.font = '60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', GAME_WIDTH / 2, GAME_HEIGHT / 2 - 30);
            ctx.font = '30px Arial';
            ctx.fillText(`Score final : ${score}`, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 30);
            ctx.fillText('Appuyez sur ESPACE ou cliquez sur Recommencer', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 80);
            resetButton.style.display = 'block'; 
        }

        // --- Fonctions de Mise √† Jour ---

        function updateEnemies() {
            const scoreBonusSpeed = Math.floor(score / 50) * 0.1;
            
            enemies.forEach((enemy, index) => {
                const currentSpeed = Math.min(3.0, ENEMY_SPEED_BASE + scoreBonusSpeed);
                const dx = player.x - enemy.x;
                const dy = player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 1) {
                    enemy.x += (dx / distance) * currentSpeed;
                    enemy.y += (dy / distance) * currentSpeed;
                }

                // Collision avec le joueur
                const collisionDist = player.size / 2 + ENEMY_SIZE / 2;
                const distPlayerEnemy = Math.sqrt(Math.pow(player.x - enemy.x, 2) + Math.pow(player.y - enemy.y, 2));
                
                if (distPlayerEnemy < collisionDist) {
                    const user = getCurrentUser();
                    // SAUVEGARDE DU SCORE (L'appel critique)
                    if (user && typeof saveGameData !== 'undefined') {
                        saveGameData(user, 'space_invaders', { score: score });
                        console.log(`Score final ${score} enregistr√© pour ${user}.`);
                    } else {
                        console.warn("Utilisateur non connect√© ou saveGameData non disponible. Score non sauvegard√©.");
                    }
                    gameOver = true;
                }
            });
        }
        
        function updatePlayer() {
            player.x += player.velX;
            player.y += player.velY;
            if (player.x < 0) player.x = 0;
            if (player.x > GAME_WIDTH) player.x = GAME_WIDTH;
            if (player.y < 0) player.y = 0;
            if (player.y > GAME_HEIGHT) player.y = GAME_HEIGHT;
            const dx = mouse.x - player.x;
            const dy = mouse.y - player.y;
            player.angle = Math.atan2(dy, dx); 
        }

        function updateBullets() {
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.velX;
                bullet.y += bullet.velY;
                if (bullet.x < 0 || bullet.x > GAME_WIDTH || bullet.y < 0 || bullet.y > GAME_HEIGHT) {
                    bullets.splice(index, 1);
                }
            });
        }

        function checkCollisions() {
            for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
                const bullet = bullets[bIndex];
                for (let eIndex = enemies.length - 1; eIndex >= 0; eIndex--) {
                    const enemy = enemies[eIndex];
                    const distance = Math.sqrt(Math.pow(bullet.x - enemy.x, 2) + Math.pow(bullet.y - enemy.y, 2));

                    if (distance < ENEMY_SIZE / 2 + 5) { 
                        enemies.splice(eIndex, 1);
                        bullets.splice(bIndex, 1);
                        score += 10;
                        scoreDisplay.textContent = score;

                        if (enemySpawnInterval > 300 && score % 200 === 0) {
                            enemySpawnInterval = Math.max(300, enemySpawnInterval - 100);
                        }
                        break; 
                    }
                }
            }
        }
        
        function shoot() {
            const now = Date.now();
            if (now - lastShotTime > FIRE_RATE) {
                lastShotTime = now;
                const velX = BULLET_SPEED * Math.cos(player.angle);
                const velY = BULLET_SPEED * Math.sin(player.angle);
                const startX = player.x + (player.size * Math.cos(player.angle));
                const startY = player.y + (player.size * Math.sin(player.angle));
                bullets.push({ x: startX, y: startY, velX, velY });
            }
        }

        function spawnEnemy() {
            const now = Date.now();
            if (now - lastSpawnTime > enemySpawnInterval) {
                lastSpawnTime = now;
                const x = Math.random() * GAME_WIDTH;
                const y = -ENEMY_SIZE;
                enemies.push({ x, y, speed: ENEMY_SPEED_BASE }); 
            }
        }
        
        function resetGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            score = 0;
            scoreDisplay.textContent = 0;
            gameOver = false;
            enemies = [];
            bullets = [];
            player.x = GAME_WIDTH / 2;
            player.y = GAME_HEIGHT - 50;
            player.velX = 0;
            player.velY = 0;
            enemySpawnInterval = 1500;
            resetButton.style.display = 'none'; 
        }
        
        function resetGameAndStart() {
            resetGame();
            gameLoop();
        }

        function gameLoop() {
            if (gameOver) {
                drawGameOver();
                animationFrameId = null;
                return;
            }

            updatePlayer();
            updateBullets();
            spawnEnemy();
            updateEnemies();
            checkCollisions();
            
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            drawPlayer();
            drawBullets();
            drawEnemies();

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // --- 3. √âv√©nements ---
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'q') player.velX = -player.speed;
            else if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') player.velX = player.speed;
            else if (e.key === 'ArrowUp' || e.key.toLowerCase() === 'z') player.velY = -player.speed;
            else if (e.key === 'ArrowDown' || e.key.toLowerCase() === 's') player.velY = player.speed;
            
            if (gameOver && e.key === ' ') { 
                e.preventDefault();
                resetGameAndStart();
            }
        });

        document.addEventListener('keyup', (e) => {
            if ((e.key === 'ArrowLeft' || e.key.toLowerCase() === 'q') && player.velX < 0) player.velX = 0;
            else if ((e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') && player.velX > 0) player.velX = 0;
            else if ((e.key === 'ArrowUp' || e.key.toLowerCase() === 'z') && player.velY < 0) player.velY = 0;
            else if ((e.key === 'ArrowDown' || e.key.toLowerCase() === 's') && player.velY > 0) player.velY = 0;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('click', () => {
            if (!gameOver) {
                shoot();
            }
        });

        // D√©marrage initial
        resetGame();
        requestAnimationFrame(gameLoop);
        
        window.resetGameAndStart = resetGameAndStart; 
    </script>
</body>
</html>
